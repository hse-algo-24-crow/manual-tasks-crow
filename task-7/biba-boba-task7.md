# Вариант 2

### Постановка задачи:
1. количество заданий произвольно;
2. все задания имеют одинаковую длительность;
3. задания зависимы, причём **граф зависимостей не должен содержать транзитивных ребер**;
4. запрещены прерывания при выполнении заданий;
5. количество **работников строго 2**;
6. работники универсальны;
7. производительность работников, размеры оплаты из труда и т.д. не учитываются;

*Требуется построить расписание выполнения всех заданий для заданного 
количества исполнителей в кратчайшие сроки.*

#### Таблица зависимостей:

| Предшествующее задание | A | A | A | A | B | B | C | D | D | E | F | F | G | H | I | J | K | L | M | M |
|------------------------|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
| Последующее задание    | D | E | I | B | C | E | F | G | H | I | I | J | K | L | M | N | O | O | O | N |

## Нарисуем исходный граф зависимостей

```mermaid
graph TB
A((A))-->D((D))
A-->E((E))
A-->I((I))
A-->B((B))
B-->C((C))
B-->E((E))
C-->F((F))
D((D))-->G((G))
D-->H((H))
E-->I
F-->J((J))
F-->I((I))
G((G))-->K((K))
H-->L((L))
I-->M((M))
J-->N((N))
K-->O((O))
L-->O
M-->O
M-->N
```

### Шаг №1 Удалим транзитивные ребра
```mermaid
graph TB
A((A))-->D((D))
A-->B((B))
B-->C((C))
B-->E((E))
C-->F((F))
D((D))-->G((G))
D-->H((H))
E-->I((I))
F-->J((J))
F-->I((I))
G((G))-->K((K))
H-->L((L))
I-->M((M))
J-->N((N))
K-->O((O))
L-->O
M-->N
M-->O
```
Мы удалили ребра **AI** и ребра **AE** т.к. в эти ребра существует путь через узел B, значит они избыточны.

### Шаг №2 Расставим приоритеты выполнения заданий
Приоритеты в первую очередь выставляются истокам графа (узлам у которых нет потомков) - это узлы N и O, соответственно назначим им приоритет 1 и 2.
Для заданий, все прямые потомки которых уже имеют приоритеты, составляется строка из приоритетов прямых потомков, записанных в убывающем порядке. Приоритет (t + 1) назначается заданию, у которого строка из приоритетов является лексикографически наименьшей.
Далее продемонстрирую распределение приоритетов продемонстрирую на графике.

```mermaid
graph TB
A((A #15 <14,11>))-->D((D #13 <7,6>))
A-->B((B #14 <13,10>))
B-->C((C #13 <12>))
B-->E((E #10 <9>))
C-->F((F #12 <9,5>))
D((D#11 <7,6>))-->G((G))
D-->H((H #7 <4>))
E-->I((I #9 <8>))
F-->J((J #5 <2>))
F-->I((I #9 <8>))
G((G #6 <3>))-->K((K #3 <1>))
H-->L((L #4 <1>))
I-->M((M #8 <2,1>))
J-->N((N))
K-->O((O))
L-->O((O #1 <>))
M-->N((N #2 <>))
M-->O
```

### Шаг №3 Составим диаграмму Ганта
Когда приоритеты для всех заданий определены, они будут размещены в расписании согласно их важности. В каждый момент времени выбираются только те задания, которые могут быть выполнены (то есть, все их предшествующие задачи уже завершены). Из доступных заданий будет выбрано то, которое имеет наибольший приоритет, и оно будет включено передано исполнителю. После этого можно построить диаграмму Ганта для визуализации процесса выполнения задач.

```mermaid
gantt
    title Диаграмма Ганта
    dateFormat HH:mm    
    axisFormat %H:%M
    Начало выполнения работ : milestone, m1, 00:00, 0h
    section Исполнитель 1
    A         :c, 00:00, 1h
    B         :i, after c, 1h    
    C         :e, after i, 1h    
    F         :h, after e, 1h
    E         :a, after h, 1h
    I         :b, after a, 1h
    M         :k, after b, 1h
    G         :m, after k, 1h
    L         :t, after m, 1h
    N         :v, after t, 1h
    section Исполнитель 2
    D         :f, 03:00, 1h
    H         :j, 06:00, 1h
    J         :x, 07:00, 1h
    K         :y, after x, 1h
    O         :z, after y, 1h
    Окончание выполнения работ : milestone, m2, 10:00, 0h
```
